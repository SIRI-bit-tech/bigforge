import winston from 'winston'
import nodemailer from 'nodemailer'

// Create email transporter using your existing Gmail setup
const emailTransporter = nodemailer.createTransport({
  host: process.env.GMAIL_HOST,
  port: 587,
  secure: false,
  auth: {
    user: process.env.GMAIL_USER,
    pass: process.env.GMAIL_APP_PASSWORD
  }
})

// Function to send error emails
const sendErrorEmail = async (logInfo: any) => {
  // Only send emails if enabled and for error level
  if (logInfo.level !== 'error' || 
      (process.env.NODE_ENV !== 'production' && process.env.ENABLE_EMAIL_ALERTS !== 'true')) {
    return
  }

  try {
    const htmlContent = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <div style="background: #f8f9fa; padding: 20px; border-left: 4px solid #dc3545;">
          <h2 style="color: #dc3545; margin: 0 0 10px 0;">ðŸš¨ BidForge Error Alert</h2>
          <p style="margin: 0; color: #666;">An error occurred in your BidForge application</p>
        </div>
        
        <div style="padding: 20px; background: white; border: 1px solid #dee2e6;">
          <h3 style="color: #333; margin-top: 0;">Error Details</h3>
          <table style="width: 100%; border-collapse: collapse;">
            <tr>
              <td style="padding: 8px; border-bottom: 1px solid #eee; font-weight: bold; width: 120px;">Level:</td>
              <td style="padding: 8px; border-bottom: 1px solid #eee;">${logInfo.level.toUpperCase()}</td>
            </tr>
            <tr>
              <td style="padding: 8px; border-bottom: 1px solid #eee; font-weight: bold;">Message:</td>
              <td style="padding: 8px; border-bottom: 1px solid #eee;">${logInfo.message}</td>
            </tr>
            <tr>
              <td style="padding: 8px; border-bottom: 1px solid #eee; font-weight: bold;">Timestamp:</td>
              <td style="padding: 8px; border-bottom: 1px solid #eee;">${logInfo.timestamp}</td>
            </tr>
            <tr>
              <td style="padding: 8px; border-bottom: 1px solid #eee; font-weight: bold;">Environment:</td>
              <td style="padding: 8px; border-bottom: 1px solid #eee;">${process.env.NODE_ENV || 'development'}</td>
            </tr>
          </table>
          
          ${logInfo.error || logInfo.stack ? `
          <h4 style="color: #333; margin: 20px 0 10px 0;">Error Details</h4>
          <pre style="background: #f8f9fa; padding: 15px; border-radius: 4px; overflow-x: auto; font-size: 12px;">${logInfo.error || logInfo.stack || 'No additional error details'}</pre>
          ` : ''}
          
          ${Object.keys(logInfo).filter(key => !['level', 'message', 'timestamp', 'error', 'stack'].includes(key)).length > 0 ? `
          <h4 style="color: #333; margin: 20px 0 10px 0;">Additional Information</h4>
          <pre style="background: #f8f9fa; padding: 15px; border-radius: 4px; overflow-x: auto; font-size: 12px;">${JSON.stringify(
            Object.fromEntries(
              Object.entries(logInfo).filter(([key]) => !['level', 'message', 'timestamp', 'error', 'stack'].includes(key))
            ), 
            null, 
            2
          )}</pre>
          ` : ''}
        </div>
        
        <div style="padding: 15px; background: #f8f9fa; text-align: center; font-size: 12px; color: #666;">
          <p style="margin: 0;">This alert was generated by BidForge Error Monitoring</p>
          <p style="margin: 5px 0 0 0;">Server: ${process.env.NODE_ENV || 'development'} | Time: ${logInfo.timestamp}</p>
        </div>
      </div>
    `

    await emailTransporter.sendMail({
      from: process.env.GMAIL_USER,
      to: process.env.GMAIL_USER,
      subject: `ðŸš¨ BidForge Error Alert - ${logInfo.level.toUpperCase()}: ${logInfo.message}`,
      html: htmlContent
    })

    // Error email sent successfully
  } catch (error) {
    // Failed to send error email - silently continue
  }
}

// Create the logger
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp({
      format: 'YYYY-MM-DD HH:mm:ss'
    }),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { 
    service: 'bidforge',
    environment: process.env.NODE_ENV || 'development'
  },
  transports: [
    // Console logging for development
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    
    // File logging for all levels
    new winston.transports.File({ 
      filename: 'logs/error.log', 
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    }),
    new winston.transports.File({ 
      filename: 'logs/combined.log',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    })
  ],
})

// If we're not in production, log to the console as well
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }))
}

// Helper functions for common logging patterns
export const logError = (message: string, error?: Error | any, metadata?: any) => {
  const logData = {
    message,
    error: error?.message || error,
    stack: error?.stack,
    timestamp: new Date().toISOString(),
    level: 'error',
    ...metadata
  }
  
  logger.error(message, logData)
  
  // Send email notification for errors
  sendErrorEmail(logData)
}

export const logWarning = (message: string, metadata?: any) => {
  logger.warn(message, metadata)
}

export const logInfo = (message: string, metadata?: any) => {
  logger.info(message, metadata)
}

export const logDebug = (message: string, metadata?: any) => {
  logger.debug(message, metadata)
}

// Express middleware for request logging
export const requestLogger = (req: any, res: any, next: any) => {
  const start = Date.now()
  
  res.on('finish', () => {
    const duration = Date.now() - start
    const logData = {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration: `${duration}ms`,
      userAgent: req.get('User-Agent'),
      ip: req.ip || req.connection.remoteAddress
    }
    
    if (res.statusCode >= 400) {
      logger.error(`HTTP ${res.statusCode} - ${req.method} ${req.url}`, logData)
    } else {
      logger.info(`HTTP ${res.statusCode} - ${req.method} ${req.url}`, logData)
    }
  })
  
  next()
}

// Global error handler
export const handleUncaughtErrors = () => {
  process.on('uncaughtException', (error) => {
    logError('Uncaught Exception', error, { 
      type: 'uncaughtException',
      critical: true 
    })
    
    // Give time for email to send before exiting
    setTimeout(() => {
      process.exit(1)
    }, 2000)
  })
  
  process.on('unhandledRejection', (reason, promise) => {
    logError('Unhandled Rejection', reason, { 
      type: 'unhandledRejection',
      promise: promise.toString(),
      critical: true 
    })
  })
}

// Initialize global error handlers
handleUncaughtErrors()

export default logger